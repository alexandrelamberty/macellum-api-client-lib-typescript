/* tslint:disable */
/* eslint-disable */
/**
 * Macellum
 * The Grocery Management System API is a robust and user-friendly interface designed to streamline and enhance grocery store operations. This API provides a comprehensive set of endpoints to manage essential tasks, including inventory management, order processing, customer interactions, and sales tracking. 
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: mail@alexandrelamberty.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Representation of an address entity, capturing information such as street, city, state, and postal code.
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * The address street.
     * @type {string}
     * @memberof Address
     */
    'street': string;
    /**
     * The address street number.
     * @type {string}
     * @memberof Address
     */
    'number': string;
    /**
     * The address postal code.
     * @type {string}
     * @memberof Address
     */
    'postal_code': string;
    /**
     * The address city.
     * @type {string}
     * @memberof Address
     */
    'city': string;
    /**
     * The address country.
     * @type {string}
     * @memberof Address
     */
    'country': string;
}
/**
 * Representation of analytics data for various entities within the system, providing insights into different data sets.
 * @export
 * @interface Analytics
 */
export interface Analytics {
    /**
     * 
     * @type {AnalyticsTotalCarts}
     * @memberof Analytics
     */
    'total_carts': AnalyticsTotalCarts;
    /**
     * 
     * @type {AnalyticsTotalCarts}
     * @memberof Analytics
     */
    'total_orders': AnalyticsTotalCarts;
    /**
     * 
     * @type {AnalyticsTotalCarts}
     * @memberof Analytics
     */
    'new_customers': AnalyticsTotalCarts;
    /**
     * 
     * @type {string}
     * @memberof Analytics
     */
    'overview': string;
    /**
     * 
     * @type {string}
     * @memberof Analytics
     */
    'recent_carts': string;
}
/**
 * 
 * @export
 * @interface AnalyticsTotalCarts
 */
export interface AnalyticsTotalCarts {
    /**
     * 
     * @type {string}
     * @memberof AnalyticsTotalCarts
     */
    'total': string;
    /**
     * 
     * @type {string}
     * @memberof AnalyticsTotalCarts
     */
    'last_month': string;
}
/**
 * Representation of a user authenticated in the system.
 * @export
 * @interface AuthUser
 */
export interface AuthUser {
    /**
     * 
     * @type {string}
     * @memberof AuthUser
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AuthUser
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof AuthUser
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof AuthUser
     */
    'token': string;
}
/**
 * Representation of a calendar entity, providing functionalities for scheduling and managing events.
 * @export
 * @interface Calendar
 */
export interface Calendar {
    /**
     * Unique identifier of the calendar.
     * @type {string}
     * @memberof Calendar
     */
    'id': string;
    /**
     * Name of the calendar.
     * @type {string}
     * @memberof Calendar
     */
    'name': string;
    /**
     * Label of the calendar.
     * @type {string}
     * @memberof Calendar
     */
    'label': string;
    /**
     * Color for the calendar.
     * @type {string}
     * @memberof Calendar
     */
    'color': string;
    /**
     * Notes about the calendar.
     * @type {string}
     * @memberof Calendar
     */
    'notes': string;
    /**
     * 
     * @type {Array<Event>}
     * @memberof Calendar
     */
    'events': Array<Event>;
    /**
     * Set to true for default calendar, non-deletable.
     * @type {boolean}
     * @memberof Calendar
     */
    'default': boolean;
}
/**
 * Representation of a shopping cart, capturing the items selected by a customer for purchase.
 * @export
 * @interface Cart
 */
export interface Cart {
    /**
     * Unique identifier of the cart.
     * @type {string}
     * @memberof Cart
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Cart
     */
    'date': string;
    /**
     * 
     * @type {Customer}
     * @memberof Cart
     */
    'customer': Customer;
    /**
     * 
     * @type {Array<Product>}
     * @memberof Cart
     */
    'products': Array<Product>;
    /**
     * 
     * @type {number}
     * @memberof Cart
     */
    'total_price': number;
    /**
     * 
     * @type {string}
     * @memberof Cart
     */
    'finalized': string;
    /**
     * 
     * @type {string}
     * @memberof Cart
     */
    'pause': string;
    /**
     * 
     * @type {string}
     * @memberof Cart
     */
    'canceled': string;
}
/**
 * 
 * @export
 * @interface CreateCalendarEventRequest
 */
export interface CreateCalendarEventRequest {
    /**
     * Unique identifier for the calendar.
     * @type {string}
     * @memberof CreateCalendarEventRequest
     */
    'calendarId': string;
    /**
     * Name or title of the calendar.
     * @type {string}
     * @memberof CreateCalendarEventRequest
     */
    'name': string;
    /**
     * Date of the calendar in the format YYYY-MM-DD.
     * @type {string}
     * @memberof CreateCalendarEventRequest
     */
    'date': string;
    /**
     * Time of the calendar in the format HH:MM (24-hour clock). Optional.
     * @type {string}
     * @memberof CreateCalendarEventRequest
     */
    'time'?: string;
}
/**
 * 
 * @export
 * @interface CreateCalendarRequest
 */
export interface CreateCalendarRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateCalendarRequest
     */
    'calendarId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCalendarRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCalendarRequest
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCalendarRequest
     */
    'time'?: string;
}
/**
 * 
 * @export
 * @interface CreateCartRequest
 */
export interface CreateCartRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateCartRequest
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCartRequest
     */
    'customerId': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateCartRequest
     */
    'productsIds': Array<string>;
}
/**
 * 
 * @export
 * @interface CreateCustomerRequest
 */
export interface CreateCustomerRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'dateOfBirth': string;
    /**
     * 
     * @type {Address}
     * @memberof CreateCustomerRequest
     */
    'address': Address;
}
/**
 * 
 * @export
 * @interface CreateNotificationRequest
 */
export interface CreateNotificationRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateNotificationRequest
     */
    'date'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateNotificationRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateNotificationRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateNotificationRequest
     */
    'recipients'?: string;
}
/**
 * 
 * @export
 * @interface CreateOrderRequest
 */
export interface CreateOrderRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateOrderRequest
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrderRequest
     */
    'providerId': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateOrderRequest
     */
    'productsIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CreateProductRequest
 */
export interface CreateProductRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateProductRequest
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateProductRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateProductRequest
     */
    'brand'?: string;
    /**
     * 
     * @type {CreateProductRequestPrice}
     * @memberof CreateProductRequest
     */
    'price'?: CreateProductRequestPrice;
    /**
     * 
     * @type {CreateProductRequestWeight}
     * @memberof CreateProductRequest
     */
    'weight'?: CreateProductRequestWeight;
    /**
     * 
     * @type {string}
     * @memberof CreateProductRequest
     */
    'providersIds'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateProductRequest
     */
    'stock'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateProductRequest
     */
    'store'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateProductRequest
     */
    'category'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateProductRequest
     */
    'product_type'?: string;
}
/**
 * 
 * @export
 * @interface CreateProductRequestPrice
 */
export interface CreateProductRequestPrice {
    /**
     * 
     * @type {string}
     * @memberof CreateProductRequestPrice
     */
    'ivat'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateProductRequestPrice
     */
    'evat'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateProductRequestPrice
     */
    'currency'?: string;
}
/**
 * 
 * @export
 * @interface CreateProductRequestWeight
 */
export interface CreateProductRequestWeight {
    /**
     * 
     * @type {string}
     * @memberof CreateProductRequestWeight
     */
    'quantity'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateProductRequestWeight
     */
    'unit'?: string;
}
/**
 * 
 * @export
 * @interface CreateProviderRequest
 */
export interface CreateProviderRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateProviderRequest
     */
    'name'?: string;
    /**
     * 
     * @type {Address}
     * @memberof CreateProviderRequest
     */
    'address'?: Address;
    /**
     * 
     * @type {string}
     * @memberof CreateProviderRequest
     */
    'website'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateProviderRequest
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateProviderRequest
     */
    'label'?: string;
}
/**
 * 
 * @export
 * @interface CreateTeamRequest
 */
export interface CreateTeamRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateTeamRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTeamRequest
     */
    'label'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTeamRequest
     */
    'color'?: string;
    /**
     * 
     * @type {Array<any>}
     * @memberof CreateTeamRequest
     */
    'membersIds'?: Array<any>;
}
/**
 * Representation of a customer entity, containing information about individuals in the system.
 * @export
 * @interface Customer
 */
export interface Customer {
    /**
     * Unique identifier of the customer.
     * @type {number}
     * @memberof Customer
     */
    'id': number;
    /**
     * Unique code for the customer. This code is used in other systems.
     * @type {string}
     * @memberof Customer
     */
    'code': string;
    /**
     * First name of the customer.
     * @type {string}
     * @memberof Customer
     */
    'first_name': string;
    /**
     * Last name of the customer.
     * @type {string}
     * @memberof Customer
     */
    'last_name': string;
    /**
     * Date of birth of the customer.
     * @type {string}
     * @memberof Customer
     */
    'birthdate': string;
    /**
     * 
     * @type {Address}
     * @memberof Customer
     */
    'address': Address;
    /**
     * Phone of the customer.
     * @type {string}
     * @memberof Customer
     */
    'phone': string;
    /**
     * Email of the customer.
     * @type {string}
     * @memberof Customer
     */
    'email': string;
    /**
     * Notes about the customer.
     * @type {string}
     * @memberof Customer
     */
    'notes': string;
    /**
     * Status of the customer.
     * @type {string}
     * @memberof Customer
     */
    'status': CustomerStatusEnum;
    /**
     * Label of the customer.
     * @type {string}
     * @memberof Customer
     */
    'label': CustomerLabelEnum;
    /**
     * Priority of the customer.
     * @type {string}
     * @memberof Customer
     */
    'priority': CustomerPriorityEnum;
}

export const CustomerStatusEnum = {
    Active: 'active',
    Inactive: 'inactive',
    Suspended: 'suspended'
} as const;

export type CustomerStatusEnum = typeof CustomerStatusEnum[keyof typeof CustomerStatusEnum];
export const CustomerLabelEnum = {
    Cpas: 'CPAS',
    Xxx: 'XXX'
} as const;

export type CustomerLabelEnum = typeof CustomerLabelEnum[keyof typeof CustomerLabelEnum];
export const CustomerPriorityEnum = {
    Low: 'low',
    Medium: 'medium',
    High: 'high'
} as const;

export type CustomerPriorityEnum = typeof CustomerPriorityEnum[keyof typeof CustomerPriorityEnum];

/**
 * Representation of an event associated with a calendar, encompassing details such as date, time, and description.
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * Unique identifier of the event.
     * @type {string}
     * @memberof Event
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'date': string;
    /**
     * 
     * @type {Calendar}
     * @memberof Event
     */
    'calendar': Calendar;
}
/**
 * 
 * @export
 * @interface GetCalendar404Response
 */
export interface GetCalendar404Response {
    /**
     * The not found error message.
     * @type {string}
     * @memberof GetCalendar404Response
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface GetUserSettings404Response
 */
export interface GetUserSettings404Response {
    /**
     * 
     * @type {string}
     * @memberof GetUserSettings404Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface InviteUserRequest
 */
export interface InviteUserRequest {
    /**
     * 
     * @type {string}
     * @memberof InviteUserRequest
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof InviteUserRequest
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof InviteUserRequest
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface LoginUserRequest
 */
export interface LoginUserRequest {
    /**
     * The user\'s email for login.
     * @type {string}
     * @memberof LoginUserRequest
     */
    'email': string;
    /**
     * The user\'s password for login.
     * @type {string}
     * @memberof LoginUserRequest
     */
    'password': string;
}
/**
 * Representation of a notification within the system, containing details about messages or alerts to users.
 * @export
 * @interface Notification
 */
export interface Notification {
    /**
     * Unique identifier of the notification.
     * @type {string}
     * @memberof Notification
     */
    'id': string;
    /**
     * Indicate if the notification comes from the system. In that case the notification cannot be deleted.
     * @type {boolean}
     * @memberof Notification
     */
    'system': boolean;
}
/**
 * Represent the details for a commercial transaction, representing a request to be submitted to a supplier.
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * Unique identifier of the order.
     * @type {string}
     * @memberof Order
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'date': string;
    /**
     * 
     * @type {Provider}
     * @memberof Order
     */
    'provider': Provider;
    /**
     * 
     * @type {Array<Product>}
     * @memberof Order
     */
    'products': Array<Product>;
}
/**
 * Representation of analytics data for various entities within the system, providing insights into different data sets.
 * @export
 * @interface Overview
 */
export interface Overview {
    /**
     * 
     * @type {AnalyticsTotalCarts}
     * @memberof Overview
     */
    'total_carts': AnalyticsTotalCarts;
    /**
     * 
     * @type {AnalyticsTotalCarts}
     * @memberof Overview
     */
    'total_orders': AnalyticsTotalCarts;
    /**
     * 
     * @type {AnalyticsTotalCarts}
     * @memberof Overview
     */
    'new_customers': AnalyticsTotalCarts;
    /**
     * 
     * @type {string}
     * @memberof Overview
     */
    'overview': string;
    /**
     * 
     * @type {string}
     * @memberof Overview
     */
    'recent_carts': string;
}
/**
 * Representation of a product available within the system, encompassing details like name, description, and pricing.
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * Unique identifier of the cart.
     * @type {string}
     * @memberof Product
     */
    'id': string;
    /**
     * Unique stock keeping unit code.
     * @type {string}
     * @memberof Product
     */
    'code': string;
    /**
     * Name of the product.
     * @type {string}
     * @memberof Product
     */
    'name': string;
    /**
     * Brand of product.
     * @type {string}
     * @memberof Product
     */
    'brand': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'unit': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'price_unit': string;
    /**
     * 
     * @type {ProductPrice}
     * @memberof Product
     */
    'price': ProductPrice;
    /**
     * 
     * @type {ProductWeight}
     * @memberof Product
     */
    'weight': ProductWeight;
    /**
     * 
     * @type {Array<Provider>}
     * @memberof Product
     */
    'providers': Array<Provider>;
    /**
     * 
     * @type {ProductStock}
     * @memberof Product
     */
    'stock': ProductStock;
    /**
     * 
     * @type {ProductStore}
     * @memberof Product
     */
    'store': ProductStore;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'category': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'product_type': ProductProductTypeEnum;
}

export const ProductProductTypeEnum = {
    Food: 'food',
    Nonfood: 'nonfood'
} as const;

export type ProductProductTypeEnum = typeof ProductProductTypeEnum[keyof typeof ProductProductTypeEnum];

/**
 * Pricing of the product.
 * @export
 * @interface ProductPrice
 */
export interface ProductPrice {
    /**
     * 
     * @type {string}
     * @memberof ProductPrice
     */
    'include_vat': string;
    /**
     * 
     * @type {string}
     * @memberof ProductPrice
     */
    'exclude_vat': string;
    /**
     * 
     * @type {string}
     * @memberof ProductPrice
     */
    'currency': string;
}
/**
 * 
 * @export
 * @interface ProductStock
 */
export interface ProductStock {
    /**
     * 
     * @type {string}
     * @memberof ProductStock
     */
    'shelf': string;
    /**
     * 
     * @type {string}
     * @memberof ProductStock
     */
    'quantity': string;
    /**
     * 
     * @type {boolean}
     * @memberof ProductStock
     */
    'in_store': boolean;
}
/**
 * 
 * @export
 * @interface ProductStore
 */
export interface ProductStore {
    /**
     * 
     * @type {string}
     * @memberof ProductStore
     */
    'shelf': string;
    /**
     * 
     * @type {string}
     * @memberof ProductStore
     */
    'quantity': string;
    /**
     * 
     * @type {boolean}
     * @memberof ProductStore
     */
    'in_stock': boolean;
}
/**
 * Weight, packaging of the product.
 * @export
 * @interface ProductWeight
 */
export interface ProductWeight {
    /**
     * 
     * @type {string}
     * @memberof ProductWeight
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof ProductWeight
     */
    'unit': ProductWeightUnitEnum;
}

export const ProductWeightUnitEnum = {
    G: 'g',
    Kg: 'kg',
    Lb: 'lb',
    Ml: 'ml',
    L: 'l'
} as const;

export type ProductWeightUnitEnum = typeof ProductWeightUnitEnum[keyof typeof ProductWeightUnitEnum];

/**
 * Representation of a product provider within the system, containing relevant information.
 * @export
 * @interface Provider
 */
export interface Provider {
    /**
     * Unique identifier of the provider.
     * @type {string}
     * @memberof Provider
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Provider
     */
    'name': string;
    /**
     * 
     * @type {Address}
     * @memberof Provider
     */
    'address': Address;
    /**
     * 
     * @type {string}
     * @memberof Provider
     */
    'website': string;
    /**
     * 
     * @type {string}
     * @memberof Provider
     */
    'phone': string;
}
/**
 * 
 * @export
 * @interface RegisterUserRequest
 */
export interface RegisterUserRequest {
    /**
     * 
     * @type {string}
     * @memberof RegisterUserRequest
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterUserRequest
     */
    'lastName': string;
    /**
     * The email to use with the account.
     * @type {string}
     * @memberof RegisterUserRequest
     */
    'email': string;
    /**
     * The password to use for the account.
     * @type {string}
     * @memberof RegisterUserRequest
     */
    'password': string;
    /**
     * Token for invited user.
     * @type {string}
     * @memberof RegisterUserRequest
     */
    'invite_token'?: string;
}
/**
 *  Representation of a report entity, capturing information or analysis generated by the system.
 * @export
 * @interface Report
 */
export interface Report {
    /**
     * 
     * @type {string}
     * @memberof Report
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Report
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Report
     */
    'date': string;
}
/**
 * Representation of user-specific settings within the system, allowing customization according to individual preferences.
 * @export
 * @interface Settings
 */
export interface Settings {
    /**
     * 
     * @type {string}
     * @memberof Settings
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Settings
     */
    'mode': SettingsModeEnum;
    /**
     * 
     * @type {string}
     * @memberof Settings
     */
    'theme': string;
    /**
     * 
     * @type {string}
     * @memberof Settings
     */
    'language': SettingsLanguageEnum;
    /**
     * Set to true if the user want to receive notifications.
     * @type {boolean}
     * @memberof Settings
     */
    'notifications': boolean;
}

export const SettingsModeEnum = {
    Light: 'light',
    Dark: 'dark',
    System: 'system'
} as const;

export type SettingsModeEnum = typeof SettingsModeEnum[keyof typeof SettingsModeEnum];
export const SettingsLanguageEnum = {
    FrBe: 'fr-BE',
    NlBe: 'nl-BE',
    DeDe: 'de-DE',
    EnUk: 'en-UK'
} as const;

export type SettingsLanguageEnum = typeof SettingsLanguageEnum[keyof typeof SettingsLanguageEnum];

/**
 * Representation of a team within the system, including details about its members and collaborative functionalities.
 * @export
 * @interface Team
 */
export interface Team {
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    'label': string;
    /**
     * 
     * @type {Array<User>}
     * @memberof Team
     */
    'members': Array<User>;
}
/**
 * 
 * @export
 * @interface UpdateCalendarEventRequest
 */
export interface UpdateCalendarEventRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateCalendarEventRequest
     */
    'calendarId': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCalendarEventRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCalendarEventRequest
     */
    'date'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCalendarEventRequest
     */
    'time'?: string;
}
/**
 * 
 * @export
 * @interface UpdateCalendarRequest
 */
export interface UpdateCalendarRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateCalendarRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCalendarRequest
     */
    'label'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCalendarRequest
     */
    'color'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCalendarRequest
     */
    'notes'?: string;
}
/**
 * 
 * @export
 * @interface UpdateCartRequest
 */
export interface UpdateCartRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateCartRequest
     */
    'date'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCartRequest
     */
    'customerId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateCartRequest
     */
    'productsId'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateCustomerRequest
 */
export interface UpdateCustomerRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'dateOfBirth'?: string;
    /**
     * 
     * @type {Address}
     * @memberof UpdateCustomerRequest
     */
    'address'?: Address;
}
/**
 * 
 * @export
 * @interface UpdateOrderRequest
 */
export interface UpdateOrderRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateOrderRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrderRequest
     */
    'providerId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateOrderRequest
     */
    'productsIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateProductRequest
 */
export interface UpdateProductRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateProductRequest
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProductRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProductRequest
     */
    'brand'?: string;
    /**
     * 
     * @type {CreateProductRequestPrice}
     * @memberof UpdateProductRequest
     */
    'price'?: CreateProductRequestPrice;
    /**
     * 
     * @type {CreateProductRequestWeight}
     * @memberof UpdateProductRequest
     */
    'weight'?: CreateProductRequestWeight;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateProductRequest
     */
    'providersIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UpdateProductRequest
     */
    'stock'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProductRequest
     */
    'store'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProductRequest
     */
    'categoryId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProductRequest
     */
    'product_type'?: string;
}
/**
 * 
 * @export
 * @interface UpdateProviderRequest
 */
export interface UpdateProviderRequest {
    /**
     * Updated name of the provider.
     * @type {string}
     * @memberof UpdateProviderRequest
     */
    'name'?: string;
    /**
     * 
     * @type {Address}
     * @memberof UpdateProviderRequest
     */
    'address'?: Address;
    /**
     * Updated website URL of the provider.
     * @type {string}
     * @memberof UpdateProviderRequest
     */
    'website'?: string;
    /**
     * Updated status of the provider.
     * @type {string}
     * @memberof UpdateProviderRequest
     */
    'status'?: string;
    /**
     * Updated label of the provider.
     * @type {string}
     * @memberof UpdateProviderRequest
     */
    'label'?: string;
}
/**
 * 
 * @export
 * @interface UpdateTeamRequest
 */
export interface UpdateTeamRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateTeamRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTeamRequest
     */
    'membersIds'?: string;
}
/**
 * 
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'dateOfBirth'?: string;
}
/**
 * 
 * @export
 * @interface UpdateUserSettingsRequest
 */
export interface UpdateUserSettingsRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserSettingsRequest
     */
    'mode'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserSettingsRequest
     */
    'theme'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserSettingsRequest
     */
    'language'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserSettingsRequest
     */
    'notifications'?: boolean;
}
/**
 * Representation of a user in the system, encompassing essential details for user management and interaction.
 * @export
 * @interface User
 */
export interface User {
    /**
     * Unique identifier for the given user.
     * @type {number}
     * @memberof User
     */
    'id': number;
    /**
     * The first name of the user.
     * @type {string}
     * @memberof User
     */
    'firstName': string;
    /**
     * The last name of the user.
     * @type {string}
     * @memberof User
     */
    'lastName': string;
    /**
     * The email of the user.
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * The date of birth of the user.
     * @type {string}
     * @memberof User
     */
    'dateOfBirth': string;
    /**
     * Set to true if the user has been invited by mail to register to the application.
     * @type {boolean}
     * @memberof User
     */
    'invited'?: boolean;
    /**
     * Set to true if the user\'s email has been verified.
     * @type {boolean}
     * @memberof User
     */
    'emailVerified': boolean;
}

/**
 * AnalyticsApi - axios parameter creator
 * @export
 */
export const AnalyticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a list of all analytics.
         * @summary Get All Analytics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalytics: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analytics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnalyticsApi - functional programming interface
 * @export
 */
export const AnalyticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnalyticsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a list of all analytics.
         * @summary Get All Analytics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnalytics(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Analytics>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnalytics(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.getAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AnalyticsApi - factory interface
 * @export
 */
export const AnalyticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnalyticsApiFp(configuration)
    return {
        /**
         * Retrieve a list of all analytics.
         * @summary Get All Analytics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalytics(options?: any): AxiosPromise<Array<Analytics>> {
            return localVarFp.getAnalytics(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnalyticsApi - object-oriented interface
 * @export
 * @class AnalyticsApi
 * @extends {BaseAPI}
 */
export class AnalyticsApi extends BaseAPI {
    /**
     * Retrieve a list of all analytics.
     * @summary Get All Analytics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public getAnalytics(options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).getAnalytics(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Log-in a user with the specified information.
         * @summary Login User
         * @param {LoginUserRequest} [loginUserRequest] Request body for login a user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser: async (loginUserRequest?: LoginUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register a new user account with the specified information.
         * @summary Register New User
         * @param {RegisterUserRequest} [registerUserRequest] Request body for registering a new user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser: async (registerUserRequest?: RegisterUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Log-in a user with the specified information.
         * @summary Login User
         * @param {LoginUserRequest} [loginUserRequest] Request body for login a user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginUser(loginUserRequest?: LoginUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginUser(loginUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.loginUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Register a new user account with the specified information.
         * @summary Register New User
         * @param {RegisterUserRequest} [registerUserRequest] Request body for registering a new user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerUser(registerUserRequest?: RegisterUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerUser(registerUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.registerUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Log-in a user with the specified information.
         * @summary Login User
         * @param {LoginUserRequest} [loginUserRequest] Request body for login a user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser(loginUserRequest?: LoginUserRequest, options?: any): AxiosPromise<AuthUser> {
            return localVarFp.loginUser(loginUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Register a new user account with the specified information.
         * @summary Register New User
         * @param {RegisterUserRequest} [registerUserRequest] Request body for registering a new user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(registerUserRequest?: RegisterUserRequest, options?: any): AxiosPromise<AuthUser> {
            return localVarFp.registerUser(registerUserRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Log-in a user with the specified information.
     * @summary Login User
     * @param {LoginUserRequest} [loginUserRequest] Request body for login a user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public loginUser(loginUserRequest?: LoginUserRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).loginUser(loginUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register a new user account with the specified information.
     * @summary Register New User
     * @param {RegisterUserRequest} [registerUserRequest] Request body for registering a new user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public registerUser(registerUserRequest?: RegisterUserRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).registerUser(registerUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CalendarApi - axios parameter creator
 * @export
 */
export const CalendarApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new calendar with the specified information.
         * @summary Create New Calendar
         * @param {CreateCalendarRequest} [createCalendarRequest] JSON object containing information for creating a new order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCalendar: async (createCalendarRequest?: CreateCalendarRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/calendars`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCalendarRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new calendar event in the calendar with ID {calendarId}.
         * @summary Create New Calendar Event
         * @param {string} calendarId Calendar unique identifier
         * @param {CreateCalendarEventRequest} [createCalendarEventRequest] Request body for creating a new calendar event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCalendarEvent: async (calendarId: string, createCalendarEventRequest?: CreateCalendarEventRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'calendarId' is not null or undefined
            assertParamExists('createCalendarEvent', 'calendarId', calendarId)
            const localVarPath = `/calendars/{calendarId}/events`
                .replace(`{${"calendarId"}}`, encodeURIComponent(String(calendarId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCalendarEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific calendar identified by {calendarId}.
         * @summary Delete Calendar
         * @param {string} calendarId Calendar unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCalendar: async (calendarId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'calendarId' is not null or undefined
            assertParamExists('deleteCalendar', 'calendarId', calendarId)
            const localVarPath = `/calendars/{calendarId}`
                .replace(`{${"calendarId"}}`, encodeURIComponent(String(calendarId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific calendar event identified by {eventId} from the calendar with ID {calendarId}.
         * @summary Delete Calendar Event
         * @param {string} calendarId Calendar unique identifier
         * @param {string} eventId Calendar Event unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCalendarEvent: async (calendarId: string, eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'calendarId' is not null or undefined
            assertParamExists('deleteCalendarEvent', 'calendarId', calendarId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('deleteCalendarEvent', 'eventId', eventId)
            const localVarPath = `/calendars/{calendarId}/events/{eventId}`
                .replace(`{${"calendarId"}}`, encodeURIComponent(String(calendarId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information for a specific calendar identified by {calendarId}.
         * @summary Get Calendar
         * @param {string} calendarId Calendar unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalendar: async (calendarId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'calendarId' is not null or undefined
            assertParamExists('getCalendar', 'calendarId', calendarId)
            const localVarPath = `/calendars/{calendarId}`
                .replace(`{${"calendarId"}}`, encodeURIComponent(String(calendarId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information for a specific calendar event identified by {eventId} specific calendar event identified by {eventId} from the calendar with ID {calendarId}.
         * @summary Get Calendar Event
         * @param {string} calendarId Calendar unique identifier
         * @param {string} eventId Calendar Event unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalendarEvent: async (calendarId: string, eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'calendarId' is not null or undefined
            assertParamExists('getCalendarEvent', 'calendarId', calendarId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getCalendarEvent', 'eventId', eventId)
            const localVarPath = `/calendars/{calendarId}/events/{eventId}`
                .replace(`{${"calendarId"}}`, encodeURIComponent(String(calendarId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all calendar events in the calendar with ID {calendarId}.
         * @summary Get All Calendar Events
         * @param {string} calendarId Calendar unique identifier
         * @param {string} [skip] Skip
         * @param {string} [limit] Limit
         * @param {string} [startDate] Start date
         * @param {string} [endDate] End date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalendarEvents: async (calendarId: string, skip?: string, limit?: string, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'calendarId' is not null or undefined
            assertParamExists('getCalendarEvents', 'calendarId', calendarId)
            const localVarPath = `/calendars/{calendarId}/events`
                .replace(`{${"calendarId"}}`, encodeURIComponent(String(calendarId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all calendars.
         * @summary Get All Calendars
         * @param {string} [skip] Skip
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalendars: async (skip?: string, limit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/calendars`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update information for a specific calendar identified by {calendarId}.
         * @summary Update Calendar
         * @param {string} calendarId Calendar unique identifier
         * @param {UpdateCalendarRequest} [updateCalendarRequest] Request body for updating a calendar.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCalendar: async (calendarId: string, updateCalendarRequest?: UpdateCalendarRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'calendarId' is not null or undefined
            assertParamExists('updateCalendar', 'calendarId', calendarId)
            const localVarPath = `/calendars/{calendarId}`
                .replace(`{${"calendarId"}}`, encodeURIComponent(String(calendarId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCalendarRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update information for a specific calendar event identified by {eventId} from the calendar with ID {calendarId}.
         * @summary Update Calendar Event
         * @param {string} calendarId Calendar unique identifier
         * @param {string} eventId Calendar Event unique identifier
         * @param {UpdateCalendarEventRequest} [updateCalendarEventRequest] Request body for updating a calendar event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCalendarEvent: async (calendarId: string, eventId: string, updateCalendarEventRequest?: UpdateCalendarEventRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'calendarId' is not null or undefined
            assertParamExists('updateCalendarEvent', 'calendarId', calendarId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateCalendarEvent', 'eventId', eventId)
            const localVarPath = `/calendars/{calendarId}/events/{eventId}`
                .replace(`{${"calendarId"}}`, encodeURIComponent(String(calendarId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCalendarEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CalendarApi - functional programming interface
 * @export
 */
export const CalendarApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CalendarApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new calendar with the specified information.
         * @summary Create New Calendar
         * @param {CreateCalendarRequest} [createCalendarRequest] JSON object containing information for creating a new order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCalendar(createCalendarRequest?: CreateCalendarRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Calendar>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCalendar(createCalendarRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CalendarApi.createCalendar']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new calendar event in the calendar with ID {calendarId}.
         * @summary Create New Calendar Event
         * @param {string} calendarId Calendar unique identifier
         * @param {CreateCalendarEventRequest} [createCalendarEventRequest] Request body for creating a new calendar event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCalendarEvent(calendarId: string, createCalendarEventRequest?: CreateCalendarEventRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCalendarEvent(calendarId, createCalendarEventRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CalendarApi.createCalendarEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a specific calendar identified by {calendarId}.
         * @summary Delete Calendar
         * @param {string} calendarId Calendar unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCalendar(calendarId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCalendar(calendarId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CalendarApi.deleteCalendar']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a specific calendar event identified by {eventId} from the calendar with ID {calendarId}.
         * @summary Delete Calendar Event
         * @param {string} calendarId Calendar unique identifier
         * @param {string} eventId Calendar Event unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCalendarEvent(calendarId: string, eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCalendarEvent(calendarId, eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CalendarApi.deleteCalendarEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve information for a specific calendar identified by {calendarId}.
         * @summary Get Calendar
         * @param {string} calendarId Calendar unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCalendar(calendarId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Calendar>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCalendar(calendarId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CalendarApi.getCalendar']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve information for a specific calendar event identified by {eventId} specific calendar event identified by {eventId} from the calendar with ID {calendarId}.
         * @summary Get Calendar Event
         * @param {string} calendarId Calendar unique identifier
         * @param {string} eventId Calendar Event unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCalendarEvent(calendarId: string, eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCalendarEvent(calendarId, eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CalendarApi.getCalendarEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all calendar events in the calendar with ID {calendarId}.
         * @summary Get All Calendar Events
         * @param {string} calendarId Calendar unique identifier
         * @param {string} [skip] Skip
         * @param {string} [limit] Limit
         * @param {string} [startDate] Start date
         * @param {string} [endDate] End date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCalendarEvents(calendarId: string, skip?: string, limit?: string, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCalendarEvents(calendarId, skip, limit, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CalendarApi.getCalendarEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all calendars.
         * @summary Get All Calendars
         * @param {string} [skip] Skip
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCalendars(skip?: string, limit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Calendar>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCalendars(skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CalendarApi.getCalendars']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update information for a specific calendar identified by {calendarId}.
         * @summary Update Calendar
         * @param {string} calendarId Calendar unique identifier
         * @param {UpdateCalendarRequest} [updateCalendarRequest] Request body for updating a calendar.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCalendar(calendarId: string, updateCalendarRequest?: UpdateCalendarRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Calendar>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCalendar(calendarId, updateCalendarRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CalendarApi.updateCalendar']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update information for a specific calendar event identified by {eventId} from the calendar with ID {calendarId}.
         * @summary Update Calendar Event
         * @param {string} calendarId Calendar unique identifier
         * @param {string} eventId Calendar Event unique identifier
         * @param {UpdateCalendarEventRequest} [updateCalendarEventRequest] Request body for updating a calendar event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCalendarEvent(calendarId: string, eventId: string, updateCalendarEventRequest?: UpdateCalendarEventRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCalendarEvent(calendarId, eventId, updateCalendarEventRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CalendarApi.updateCalendarEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CalendarApi - factory interface
 * @export
 */
export const CalendarApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CalendarApiFp(configuration)
    return {
        /**
         * Create a new calendar with the specified information.
         * @summary Create New Calendar
         * @param {CreateCalendarRequest} [createCalendarRequest] JSON object containing information for creating a new order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCalendar(createCalendarRequest?: CreateCalendarRequest, options?: any): AxiosPromise<Calendar> {
            return localVarFp.createCalendar(createCalendarRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new calendar event in the calendar with ID {calendarId}.
         * @summary Create New Calendar Event
         * @param {string} calendarId Calendar unique identifier
         * @param {CreateCalendarEventRequest} [createCalendarEventRequest] Request body for creating a new calendar event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCalendarEvent(calendarId: string, createCalendarEventRequest?: CreateCalendarEventRequest, options?: any): AxiosPromise<Event> {
            return localVarFp.createCalendarEvent(calendarId, createCalendarEventRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific calendar identified by {calendarId}.
         * @summary Delete Calendar
         * @param {string} calendarId Calendar unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCalendar(calendarId: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.deleteCalendar(calendarId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific calendar event identified by {eventId} from the calendar with ID {calendarId}.
         * @summary Delete Calendar Event
         * @param {string} calendarId Calendar unique identifier
         * @param {string} eventId Calendar Event unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCalendarEvent(calendarId: string, eventId: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.deleteCalendarEvent(calendarId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve information for a specific calendar identified by {calendarId}.
         * @summary Get Calendar
         * @param {string} calendarId Calendar unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalendar(calendarId: string, options?: any): AxiosPromise<Calendar> {
            return localVarFp.getCalendar(calendarId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve information for a specific calendar event identified by {eventId} specific calendar event identified by {eventId} from the calendar with ID {calendarId}.
         * @summary Get Calendar Event
         * @param {string} calendarId Calendar unique identifier
         * @param {string} eventId Calendar Event unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalendarEvent(calendarId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return localVarFp.getCalendarEvent(calendarId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all calendar events in the calendar with ID {calendarId}.
         * @summary Get All Calendar Events
         * @param {string} calendarId Calendar unique identifier
         * @param {string} [skip] Skip
         * @param {string} [limit] Limit
         * @param {string} [startDate] Start date
         * @param {string} [endDate] End date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalendarEvents(calendarId: string, skip?: string, limit?: string, startDate?: string, endDate?: string, options?: any): AxiosPromise<Array<Event>> {
            return localVarFp.getCalendarEvents(calendarId, skip, limit, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all calendars.
         * @summary Get All Calendars
         * @param {string} [skip] Skip
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalendars(skip?: string, limit?: string, options?: any): AxiosPromise<Array<Calendar>> {
            return localVarFp.getCalendars(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update information for a specific calendar identified by {calendarId}.
         * @summary Update Calendar
         * @param {string} calendarId Calendar unique identifier
         * @param {UpdateCalendarRequest} [updateCalendarRequest] Request body for updating a calendar.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCalendar(calendarId: string, updateCalendarRequest?: UpdateCalendarRequest, options?: any): AxiosPromise<Calendar> {
            return localVarFp.updateCalendar(calendarId, updateCalendarRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update information for a specific calendar event identified by {eventId} from the calendar with ID {calendarId}.
         * @summary Update Calendar Event
         * @param {string} calendarId Calendar unique identifier
         * @param {string} eventId Calendar Event unique identifier
         * @param {UpdateCalendarEventRequest} [updateCalendarEventRequest] Request body for updating a calendar event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCalendarEvent(calendarId: string, eventId: string, updateCalendarEventRequest?: UpdateCalendarEventRequest, options?: any): AxiosPromise<Event> {
            return localVarFp.updateCalendarEvent(calendarId, eventId, updateCalendarEventRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CalendarApi - object-oriented interface
 * @export
 * @class CalendarApi
 * @extends {BaseAPI}
 */
export class CalendarApi extends BaseAPI {
    /**
     * Create a new calendar with the specified information.
     * @summary Create New Calendar
     * @param {CreateCalendarRequest} [createCalendarRequest] JSON object containing information for creating a new order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalendarApi
     */
    public createCalendar(createCalendarRequest?: CreateCalendarRequest, options?: RawAxiosRequestConfig) {
        return CalendarApiFp(this.configuration).createCalendar(createCalendarRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new calendar event in the calendar with ID {calendarId}.
     * @summary Create New Calendar Event
     * @param {string} calendarId Calendar unique identifier
     * @param {CreateCalendarEventRequest} [createCalendarEventRequest] Request body for creating a new calendar event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalendarApi
     */
    public createCalendarEvent(calendarId: string, createCalendarEventRequest?: CreateCalendarEventRequest, options?: RawAxiosRequestConfig) {
        return CalendarApiFp(this.configuration).createCalendarEvent(calendarId, createCalendarEventRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific calendar identified by {calendarId}.
     * @summary Delete Calendar
     * @param {string} calendarId Calendar unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalendarApi
     */
    public deleteCalendar(calendarId: string, options?: RawAxiosRequestConfig) {
        return CalendarApiFp(this.configuration).deleteCalendar(calendarId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific calendar event identified by {eventId} from the calendar with ID {calendarId}.
     * @summary Delete Calendar Event
     * @param {string} calendarId Calendar unique identifier
     * @param {string} eventId Calendar Event unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalendarApi
     */
    public deleteCalendarEvent(calendarId: string, eventId: string, options?: RawAxiosRequestConfig) {
        return CalendarApiFp(this.configuration).deleteCalendarEvent(calendarId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve information for a specific calendar identified by {calendarId}.
     * @summary Get Calendar
     * @param {string} calendarId Calendar unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalendarApi
     */
    public getCalendar(calendarId: string, options?: RawAxiosRequestConfig) {
        return CalendarApiFp(this.configuration).getCalendar(calendarId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve information for a specific calendar event identified by {eventId} specific calendar event identified by {eventId} from the calendar with ID {calendarId}.
     * @summary Get Calendar Event
     * @param {string} calendarId Calendar unique identifier
     * @param {string} eventId Calendar Event unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalendarApi
     */
    public getCalendarEvent(calendarId: string, eventId: string, options?: RawAxiosRequestConfig) {
        return CalendarApiFp(this.configuration).getCalendarEvent(calendarId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all calendar events in the calendar with ID {calendarId}.
     * @summary Get All Calendar Events
     * @param {string} calendarId Calendar unique identifier
     * @param {string} [skip] Skip
     * @param {string} [limit] Limit
     * @param {string} [startDate] Start date
     * @param {string} [endDate] End date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalendarApi
     */
    public getCalendarEvents(calendarId: string, skip?: string, limit?: string, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return CalendarApiFp(this.configuration).getCalendarEvents(calendarId, skip, limit, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all calendars.
     * @summary Get All Calendars
     * @param {string} [skip] Skip
     * @param {string} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalendarApi
     */
    public getCalendars(skip?: string, limit?: string, options?: RawAxiosRequestConfig) {
        return CalendarApiFp(this.configuration).getCalendars(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update information for a specific calendar identified by {calendarId}.
     * @summary Update Calendar
     * @param {string} calendarId Calendar unique identifier
     * @param {UpdateCalendarRequest} [updateCalendarRequest] Request body for updating a calendar.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalendarApi
     */
    public updateCalendar(calendarId: string, updateCalendarRequest?: UpdateCalendarRequest, options?: RawAxiosRequestConfig) {
        return CalendarApiFp(this.configuration).updateCalendar(calendarId, updateCalendarRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update information for a specific calendar event identified by {eventId} from the calendar with ID {calendarId}.
     * @summary Update Calendar Event
     * @param {string} calendarId Calendar unique identifier
     * @param {string} eventId Calendar Event unique identifier
     * @param {UpdateCalendarEventRequest} [updateCalendarEventRequest] Request body for updating a calendar event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalendarApi
     */
    public updateCalendarEvent(calendarId: string, eventId: string, updateCalendarEventRequest?: UpdateCalendarEventRequest, options?: RawAxiosRequestConfig) {
        return CalendarApiFp(this.configuration).updateCalendarEvent(calendarId, eventId, updateCalendarEventRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CartApi - axios parameter creator
 * @export
 */
export const CartApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new cart with the specified information.
         * @summary Create New Cart
         * @param {CreateCartRequest} [createCartRequest] Request body for creating a new cart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCart: async (createCartRequest?: CreateCartRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/carts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCartRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific cart identified by {cartId}.
         * @summary Delete Cart
         * @param {string} cartId Cart unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCart: async (cartId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cartId' is not null or undefined
            assertParamExists('deleteCart', 'cartId', cartId)
            const localVarPath = `/carts/{cartId}`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information for a specific cart identified by {cartId}.
         * @summary Get Cart
         * @param {string} cartId Cart unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCart: async (cartId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cartId' is not null or undefined
            assertParamExists('getCart', 'cartId', cartId)
            const localVarPath = `/carts/{cartId}`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all carts in the system.
         * @summary Get All Carts
         * @param {string} [skip] Skip
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarts: async (skip?: string, limit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/carts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update information for a specific cart identified by {cartId}.
         * @summary Update Cart
         * @param {string} cartId Cart unique identifier
         * @param {UpdateCartRequest} [updateCartRequest] Request body for updating a cart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCart: async (cartId: string, updateCartRequest?: UpdateCartRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cartId' is not null or undefined
            assertParamExists('updateCart', 'cartId', cartId)
            const localVarPath = `/carts/{cartId}`
                .replace(`{${"cartId"}}`, encodeURIComponent(String(cartId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCartRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CartApi - functional programming interface
 * @export
 */
export const CartApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CartApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new cart with the specified information.
         * @summary Create New Cart
         * @param {CreateCartRequest} [createCartRequest] Request body for creating a new cart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCart(createCartRequest?: CreateCartRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cart>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCart(createCartRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CartApi.createCart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a specific cart identified by {cartId}.
         * @summary Delete Cart
         * @param {string} cartId Cart unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCart(cartId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCart(cartId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CartApi.deleteCart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve information for a specific cart identified by {cartId}.
         * @summary Get Cart
         * @param {string} cartId Cart unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCart(cartId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cart>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCart(cartId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CartApi.getCart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all carts in the system.
         * @summary Get All Carts
         * @param {string} [skip] Skip
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCarts(skip?: string, limit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Cart>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCarts(skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CartApi.getCarts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update information for a specific cart identified by {cartId}.
         * @summary Update Cart
         * @param {string} cartId Cart unique identifier
         * @param {UpdateCartRequest} [updateCartRequest] Request body for updating a cart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCart(cartId: string, updateCartRequest?: UpdateCartRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cart>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCart(cartId, updateCartRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CartApi.updateCart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CartApi - factory interface
 * @export
 */
export const CartApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CartApiFp(configuration)
    return {
        /**
         * Create a new cart with the specified information.
         * @summary Create New Cart
         * @param {CreateCartRequest} [createCartRequest] Request body for creating a new cart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCart(createCartRequest?: CreateCartRequest, options?: any): AxiosPromise<Cart> {
            return localVarFp.createCart(createCartRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific cart identified by {cartId}.
         * @summary Delete Cart
         * @param {string} cartId Cart unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCart(cartId: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.deleteCart(cartId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve information for a specific cart identified by {cartId}.
         * @summary Get Cart
         * @param {string} cartId Cart unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCart(cartId: string, options?: any): AxiosPromise<Cart> {
            return localVarFp.getCart(cartId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all carts in the system.
         * @summary Get All Carts
         * @param {string} [skip] Skip
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarts(skip?: string, limit?: string, options?: any): AxiosPromise<Array<Cart>> {
            return localVarFp.getCarts(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update information for a specific cart identified by {cartId}.
         * @summary Update Cart
         * @param {string} cartId Cart unique identifier
         * @param {UpdateCartRequest} [updateCartRequest] Request body for updating a cart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCart(cartId: string, updateCartRequest?: UpdateCartRequest, options?: any): AxiosPromise<Cart> {
            return localVarFp.updateCart(cartId, updateCartRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CartApi - object-oriented interface
 * @export
 * @class CartApi
 * @extends {BaseAPI}
 */
export class CartApi extends BaseAPI {
    /**
     * Create a new cart with the specified information.
     * @summary Create New Cart
     * @param {CreateCartRequest} [createCartRequest] Request body for creating a new cart.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartApi
     */
    public createCart(createCartRequest?: CreateCartRequest, options?: RawAxiosRequestConfig) {
        return CartApiFp(this.configuration).createCart(createCartRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific cart identified by {cartId}.
     * @summary Delete Cart
     * @param {string} cartId Cart unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartApi
     */
    public deleteCart(cartId: string, options?: RawAxiosRequestConfig) {
        return CartApiFp(this.configuration).deleteCart(cartId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve information for a specific cart identified by {cartId}.
     * @summary Get Cart
     * @param {string} cartId Cart unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartApi
     */
    public getCart(cartId: string, options?: RawAxiosRequestConfig) {
        return CartApiFp(this.configuration).getCart(cartId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all carts in the system.
     * @summary Get All Carts
     * @param {string} [skip] Skip
     * @param {string} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartApi
     */
    public getCarts(skip?: string, limit?: string, options?: RawAxiosRequestConfig) {
        return CartApiFp(this.configuration).getCarts(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update information for a specific cart identified by {cartId}.
     * @summary Update Cart
     * @param {string} cartId Cart unique identifier
     * @param {UpdateCartRequest} [updateCartRequest] Request body for updating a cart.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartApi
     */
    public updateCart(cartId: string, updateCartRequest?: UpdateCartRequest, options?: RawAxiosRequestConfig) {
        return CartApiFp(this.configuration).updateCart(cartId, updateCartRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CustomerApi - axios parameter creator
 * @export
 */
export const CustomerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new customer with the specified information.
         * @summary Create New Customer
         * @param {CreateCustomerRequest} [createCustomerRequest] Request body for creating a new customer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer: async (createCustomerRequest?: CreateCustomerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCustomerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific customer identified by {customerId}.  This will delete only a customer without any cart.
         * @summary Delete Customer
         * @param {string} customerId Customer unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomer: async (customerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('deleteCustomer', 'customerId', customerId)
            const localVarPath = `/customers/{customerId}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information for a specific customer identified by {customerId}.
         * @summary Get Customer
         * @param {string} customerId Customer unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer: async (customerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('getCustomer', 'customerId', customerId)
            const localVarPath = `/customers/{customerId}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all customers in the system.
         * @summary Get All Customers
         * @param {string} [skip] Skip
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomers: async (skip?: string, limit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update information for a specific customer identified by {customerId}.
         * @summary Update Customer
         * @param {string} customerId Customer unique identifier
         * @param {UpdateCustomerRequest} [updateCustomerRequest] Update customer requests.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomer: async (customerId: string, updateCustomerRequest?: UpdateCustomerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('updateCustomer', 'customerId', customerId)
            const localVarPath = `/customers/{customerId}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCustomerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerApi - functional programming interface
 * @export
 */
export const CustomerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomerApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new customer with the specified information.
         * @summary Create New Customer
         * @param {CreateCustomerRequest} [createCustomerRequest] Request body for creating a new customer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomer(createCustomerRequest?: CreateCustomerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomer(createCustomerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerApi.createCustomer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a specific customer identified by {customerId}.  This will delete only a customer without any cart.
         * @summary Delete Customer
         * @param {string} customerId Customer unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomer(customerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomer(customerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerApi.deleteCustomer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve information for a specific customer identified by {customerId}.
         * @summary Get Customer
         * @param {string} customerId Customer unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomer(customerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomer(customerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerApi.getCustomer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all customers in the system.
         * @summary Get All Customers
         * @param {string} [skip] Skip
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomers(skip?: string, limit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Customer>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomers(skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerApi.getCustomers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update information for a specific customer identified by {customerId}.
         * @summary Update Customer
         * @param {string} customerId Customer unique identifier
         * @param {UpdateCustomerRequest} [updateCustomerRequest] Update customer requests.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomer(customerId: string, updateCustomerRequest?: UpdateCustomerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCustomer(customerId, updateCustomerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerApi.updateCustomer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CustomerApi - factory interface
 * @export
 */
export const CustomerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomerApiFp(configuration)
    return {
        /**
         * Create a new customer with the specified information.
         * @summary Create New Customer
         * @param {CreateCustomerRequest} [createCustomerRequest] Request body for creating a new customer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer(createCustomerRequest?: CreateCustomerRequest, options?: any): AxiosPromise<Customer> {
            return localVarFp.createCustomer(createCustomerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific customer identified by {customerId}.  This will delete only a customer without any cart.
         * @summary Delete Customer
         * @param {string} customerId Customer unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomer(customerId: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.deleteCustomer(customerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve information for a specific customer identified by {customerId}.
         * @summary Get Customer
         * @param {string} customerId Customer unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer(customerId: string, options?: any): AxiosPromise<Customer> {
            return localVarFp.getCustomer(customerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all customers in the system.
         * @summary Get All Customers
         * @param {string} [skip] Skip
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomers(skip?: string, limit?: string, options?: any): AxiosPromise<Array<Customer>> {
            return localVarFp.getCustomers(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update information for a specific customer identified by {customerId}.
         * @summary Update Customer
         * @param {string} customerId Customer unique identifier
         * @param {UpdateCustomerRequest} [updateCustomerRequest] Update customer requests.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomer(customerId: string, updateCustomerRequest?: UpdateCustomerRequest, options?: any): AxiosPromise<Customer> {
            return localVarFp.updateCustomer(customerId, updateCustomerRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomerApi - object-oriented interface
 * @export
 * @class CustomerApi
 * @extends {BaseAPI}
 */
export class CustomerApi extends BaseAPI {
    /**
     * Create a new customer with the specified information.
     * @summary Create New Customer
     * @param {CreateCustomerRequest} [createCustomerRequest] Request body for creating a new customer.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public createCustomer(createCustomerRequest?: CreateCustomerRequest, options?: RawAxiosRequestConfig) {
        return CustomerApiFp(this.configuration).createCustomer(createCustomerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific customer identified by {customerId}.  This will delete only a customer without any cart.
     * @summary Delete Customer
     * @param {string} customerId Customer unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public deleteCustomer(customerId: string, options?: RawAxiosRequestConfig) {
        return CustomerApiFp(this.configuration).deleteCustomer(customerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve information for a specific customer identified by {customerId}.
     * @summary Get Customer
     * @param {string} customerId Customer unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public getCustomer(customerId: string, options?: RawAxiosRequestConfig) {
        return CustomerApiFp(this.configuration).getCustomer(customerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all customers in the system.
     * @summary Get All Customers
     * @param {string} [skip] Skip
     * @param {string} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public getCustomers(skip?: string, limit?: string, options?: RawAxiosRequestConfig) {
        return CustomerApiFp(this.configuration).getCustomers(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update information for a specific customer identified by {customerId}.
     * @summary Update Customer
     * @param {string} customerId Customer unique identifier
     * @param {UpdateCustomerRequest} [updateCustomerRequest] Update customer requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public updateCustomer(customerId: string, updateCustomerRequest?: UpdateCustomerRequest, options?: RawAxiosRequestConfig) {
        return CustomerApiFp(this.configuration).updateCustomer(customerId, updateCustomerRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NotificationApi - axios parameter creator
 * @export
 */
export const NotificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Ceate a new notification with the specified information.
         * @summary Create New Notification
         * @param {CreateNotificationRequest} [createNotificationRequest] JSON object containing information for creating a new notification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotification: async (createNotificationRequest?: CreateNotificationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNotificationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific notification identified by {notificationId}. Only notifications that are not yet done and that are not from the system can be deleted.
         * @summary Delete Notification
         * @param {string} notificationId Notification unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotification: async (notificationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('deleteNotification', 'notificationId', notificationId)
            const localVarPath = `/notifications/{notificationId}`
                .replace(`{${"notificationId"}}`, encodeURIComponent(String(notificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve settings information for a specific user identified by {userId}.
         * @summary Get Notification
         * @param {string} notificationId Notification unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotification: async (notificationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('getNotification', 'notificationId', notificationId)
            const localVarPath = `/notifications/{notificationId}`
                .replace(`{${"notificationId"}}`, encodeURIComponent(String(notificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all the notifications in the system.
         * @summary Get All Notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update information for a specific notification identified by {notificationId}.  Only notifications that are not yet done and that are not from the system can be updated.
         * @summary Update Notification
         * @param {string} notificationId Notification unique identifier
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNitofication: async (notificationId: string, body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('updateNitofication', 'notificationId', notificationId)
            const localVarPath = `/notifications/{notificationId}`
                .replace(`{${"notificationId"}}`, encodeURIComponent(String(notificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationApi - functional programming interface
 * @export
 */
export const NotificationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationApiAxiosParamCreator(configuration)
    return {
        /**
         * Ceate a new notification with the specified information.
         * @summary Create New Notification
         * @param {CreateNotificationRequest} [createNotificationRequest] JSON object containing information for creating a new notification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNotification(createNotificationRequest?: CreateNotificationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNotification(createNotificationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationApi.createNotification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a specific notification identified by {notificationId}. Only notifications that are not yet done and that are not from the system can be deleted.
         * @summary Delete Notification
         * @param {string} notificationId Notification unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNotification(notificationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNotification(notificationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationApi.deleteNotification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve settings information for a specific user identified by {userId}.
         * @summary Get Notification
         * @param {string} notificationId Notification unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotification(notificationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotification(notificationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationApi.getNotification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all the notifications in the system.
         * @summary Get All Notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotifications(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Notification>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotifications(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationApi.getNotifications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update information for a specific notification identified by {notificationId}.  Only notifications that are not yet done and that are not from the system can be updated.
         * @summary Update Notification
         * @param {string} notificationId Notification unique identifier
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNitofication(notificationId: string, body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNitofication(notificationId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationApi.updateNitofication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NotificationApi - factory interface
 * @export
 */
export const NotificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationApiFp(configuration)
    return {
        /**
         * Ceate a new notification with the specified information.
         * @summary Create New Notification
         * @param {CreateNotificationRequest} [createNotificationRequest] JSON object containing information for creating a new notification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotification(createNotificationRequest?: CreateNotificationRequest, options?: any): AxiosPromise<Notification> {
            return localVarFp.createNotification(createNotificationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific notification identified by {notificationId}. Only notifications that are not yet done and that are not from the system can be deleted.
         * @summary Delete Notification
         * @param {string} notificationId Notification unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotification(notificationId: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteNotification(notificationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve settings information for a specific user identified by {userId}.
         * @summary Get Notification
         * @param {string} notificationId Notification unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotification(notificationId: string, options?: any): AxiosPromise<Notification> {
            return localVarFp.getNotification(notificationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all the notifications in the system.
         * @summary Get All Notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications(options?: any): AxiosPromise<Array<Notification>> {
            return localVarFp.getNotifications(options).then((request) => request(axios, basePath));
        },
        /**
         * Update information for a specific notification identified by {notificationId}.  Only notifications that are not yet done and that are not from the system can be updated.
         * @summary Update Notification
         * @param {string} notificationId Notification unique identifier
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNitofication(notificationId: string, body?: object, options?: any): AxiosPromise<Notification> {
            return localVarFp.updateNitofication(notificationId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationApi - object-oriented interface
 * @export
 * @class NotificationApi
 * @extends {BaseAPI}
 */
export class NotificationApi extends BaseAPI {
    /**
     * Ceate a new notification with the specified information.
     * @summary Create New Notification
     * @param {CreateNotificationRequest} [createNotificationRequest] JSON object containing information for creating a new notification.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public createNotification(createNotificationRequest?: CreateNotificationRequest, options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).createNotification(createNotificationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific notification identified by {notificationId}. Only notifications that are not yet done and that are not from the system can be deleted.
     * @summary Delete Notification
     * @param {string} notificationId Notification unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public deleteNotification(notificationId: string, options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).deleteNotification(notificationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve settings information for a specific user identified by {userId}.
     * @summary Get Notification
     * @param {string} notificationId Notification unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public getNotification(notificationId: string, options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).getNotification(notificationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all the notifications in the system.
     * @summary Get All Notifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public getNotifications(options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).getNotifications(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update information for a specific notification identified by {notificationId}.  Only notifications that are not yet done and that are not from the system can be updated.
     * @summary Update Notification
     * @param {string} notificationId Notification unique identifier
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public updateNitofication(notificationId: string, body?: object, options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).updateNitofication(notificationId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrderApi - axios parameter creator
 * @export
 */
export const OrderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new order with the specified information.
         * @summary Create New Order
         * @param {CreateOrderRequest} [createOrderRequest] Create a new order with the specified information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder: async (createOrderRequest?: CreateOrderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific order identified by {orderId}.
         * @summary Delete Order
         * @param {string} orderId Order unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrder: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('deleteOrder', 'orderId', orderId)
            const localVarPath = `/orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information for a specific order identified by {orderId}.
         * @summary Get Order
         * @param {string} orderId Order unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('getOrder', 'orderId', orderId)
            const localVarPath = `/orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all orders placed.
         * @summary Get All Orders
         * @param {string} [skip] Skip
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders: async (skip?: string, limit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update information for a specific order identified by {orderId}.
         * @summary Update Order
         * @param {string} orderId Order unique identifier
         * @param {UpdateOrderRequest} [updateOrderRequest] JSON object containing information for updating an order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrder: async (orderId: string, updateOrderRequest?: UpdateOrderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('updateOrder', 'orderId', orderId)
            const localVarPath = `/orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderApi - functional programming interface
 * @export
 */
export const OrderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrderApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new order with the specified information.
         * @summary Create New Order
         * @param {CreateOrderRequest} [createOrderRequest] Create a new order with the specified information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrder(createOrderRequest?: CreateOrderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrder(createOrderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.createOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a specific order identified by {orderId}.
         * @summary Delete Order
         * @param {string} orderId Order unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrder(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrder(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.deleteOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve information for a specific order identified by {orderId}.
         * @summary Get Order
         * @param {string} orderId Order unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrder(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrder(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.getOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all orders placed.
         * @summary Get All Orders
         * @param {string} [skip] Skip
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrders(skip?: string, limit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Order>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrders(skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.getOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update information for a specific order identified by {orderId}.
         * @summary Update Order
         * @param {string} orderId Order unique identifier
         * @param {UpdateOrderRequest} [updateOrderRequest] JSON object containing information for updating an order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrder(orderId: string, updateOrderRequest?: UpdateOrderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrder(orderId, updateOrderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.updateOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrderApi - factory interface
 * @export
 */
export const OrderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrderApiFp(configuration)
    return {
        /**
         * Create a new order with the specified information.
         * @summary Create New Order
         * @param {CreateOrderRequest} [createOrderRequest] Create a new order with the specified information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder(createOrderRequest?: CreateOrderRequest, options?: any): AxiosPromise<Order> {
            return localVarFp.createOrder(createOrderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific order identified by {orderId}.
         * @summary Delete Order
         * @param {string} orderId Order unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrder(orderId: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.deleteOrder(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve information for a specific order identified by {orderId}.
         * @summary Get Order
         * @param {string} orderId Order unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder(orderId: string, options?: any): AxiosPromise<Order> {
            return localVarFp.getOrder(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all orders placed.
         * @summary Get All Orders
         * @param {string} [skip] Skip
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders(skip?: string, limit?: string, options?: any): AxiosPromise<Array<Order>> {
            return localVarFp.getOrders(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update information for a specific order identified by {orderId}.
         * @summary Update Order
         * @param {string} orderId Order unique identifier
         * @param {UpdateOrderRequest} [updateOrderRequest] JSON object containing information for updating an order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrder(orderId: string, updateOrderRequest?: UpdateOrderRequest, options?: any): AxiosPromise<Order> {
            return localVarFp.updateOrder(orderId, updateOrderRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrderApi - object-oriented interface
 * @export
 * @class OrderApi
 * @extends {BaseAPI}
 */
export class OrderApi extends BaseAPI {
    /**
     * Create a new order with the specified information.
     * @summary Create New Order
     * @param {CreateOrderRequest} [createOrderRequest] Create a new order with the specified information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public createOrder(createOrderRequest?: CreateOrderRequest, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).createOrder(createOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific order identified by {orderId}.
     * @summary Delete Order
     * @param {string} orderId Order unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public deleteOrder(orderId: string, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).deleteOrder(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve information for a specific order identified by {orderId}.
     * @summary Get Order
     * @param {string} orderId Order unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getOrder(orderId: string, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).getOrder(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all orders placed.
     * @summary Get All Orders
     * @param {string} [skip] Skip
     * @param {string} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getOrders(skip?: string, limit?: string, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).getOrders(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update information for a specific order identified by {orderId}.
     * @summary Update Order
     * @param {string} orderId Order unique identifier
     * @param {UpdateOrderRequest} [updateOrderRequest] JSON object containing information for updating an order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public updateOrder(orderId: string, updateOrderRequest?: UpdateOrderRequest, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).updateOrder(orderId, updateOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OverviewApi - axios parameter creator
 * @export
 */
export const OverviewApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve an overview of the system data.
         * @summary Get Overview
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverview: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/overview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OverviewApi - functional programming interface
 * @export
 */
export const OverviewApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OverviewApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve an overview of the system data.
         * @summary Get Overview
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOverview(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Overview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOverview(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OverviewApi.getOverview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OverviewApi - factory interface
 * @export
 */
export const OverviewApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OverviewApiFp(configuration)
    return {
        /**
         * Retrieve an overview of the system data.
         * @summary Get Overview
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverview(options?: any): AxiosPromise<Overview> {
            return localVarFp.getOverview(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OverviewApi - object-oriented interface
 * @export
 * @class OverviewApi
 * @extends {BaseAPI}
 */
export class OverviewApi extends BaseAPI {
    /**
     * Retrieve an overview of the system data.
     * @summary Get Overview
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OverviewApi
     */
    public getOverview(options?: RawAxiosRequestConfig) {
        return OverviewApiFp(this.configuration).getOverview(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductApi - axios parameter creator
 * @export
 */
export const ProductApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new product with the specified information.
         * @summary Create New Product
         * @param {CreateProductRequest} [createProductRequest] Create new product requests.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct: async (createProductRequest?: CreateProductRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProductRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific product identified by {productId}.
         * @summary Delete Product
         * @param {string} productId Product unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct: async (productId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('deleteProduct', 'productId', productId)
            const localVarPath = `/products/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information for a specific product identified by {productId}.
         * @summary Get Product
         * @param {string} productId Product unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct: async (productId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getProduct', 'productId', productId)
            const localVarPath = `/products/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all products available.
         * @summary Get All Products
         * @param {string} [skip] Skip
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducts: async (skip?: string, limit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update information for a specific product identified by {productId}.
         * @summary Update Product
         * @param {string} productId Product unique identifier
         * @param {UpdateProductRequest} [updateProductRequest] Update product requests.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct: async (productId: string, updateProductRequest?: UpdateProductRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('updateProduct', 'productId', productId)
            const localVarPath = `/products/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProductRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductApi - functional programming interface
 * @export
 */
export const ProductApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new product with the specified information.
         * @summary Create New Product
         * @param {CreateProductRequest} [createProductRequest] Create new product requests.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProduct(createProductRequest?: CreateProductRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProduct(createProductRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.createProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a specific product identified by {productId}.
         * @summary Delete Product
         * @param {string} productId Product unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProduct(productId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProduct(productId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.deleteProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve information for a specific product identified by {productId}.
         * @summary Get Product
         * @param {string} productId Product unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProduct(productId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProduct(productId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.getProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all products available.
         * @summary Get All Products
         * @param {string} [skip] Skip
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProducts(skip?: string, limit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Product>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProducts(skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.getProducts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update information for a specific product identified by {productId}.
         * @summary Update Product
         * @param {string} productId Product unique identifier
         * @param {UpdateProductRequest} [updateProductRequest] Update product requests.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProduct(productId: string, updateProductRequest?: UpdateProductRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProduct(productId, updateProductRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.updateProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductApi - factory interface
 * @export
 */
export const ProductApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductApiFp(configuration)
    return {
        /**
         * Create a new product with the specified information.
         * @summary Create New Product
         * @param {CreateProductRequest} [createProductRequest] Create new product requests.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct(createProductRequest?: CreateProductRequest, options?: any): AxiosPromise<Product> {
            return localVarFp.createProduct(createProductRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific product identified by {productId}.
         * @summary Delete Product
         * @param {string} productId Product unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct(productId: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.deleteProduct(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve information for a specific product identified by {productId}.
         * @summary Get Product
         * @param {string} productId Product unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct(productId: string, options?: any): AxiosPromise<Product> {
            return localVarFp.getProduct(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all products available.
         * @summary Get All Products
         * @param {string} [skip] Skip
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducts(skip?: string, limit?: string, options?: any): AxiosPromise<Array<Product>> {
            return localVarFp.getProducts(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update information for a specific product identified by {productId}.
         * @summary Update Product
         * @param {string} productId Product unique identifier
         * @param {UpdateProductRequest} [updateProductRequest] Update product requests.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct(productId: string, updateProductRequest?: UpdateProductRequest, options?: any): AxiosPromise<Product> {
            return localVarFp.updateProduct(productId, updateProductRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductApi - object-oriented interface
 * @export
 * @class ProductApi
 * @extends {BaseAPI}
 */
export class ProductApi extends BaseAPI {
    /**
     * Create a new product with the specified information.
     * @summary Create New Product
     * @param {CreateProductRequest} [createProductRequest] Create new product requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public createProduct(createProductRequest?: CreateProductRequest, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).createProduct(createProductRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific product identified by {productId}.
     * @summary Delete Product
     * @param {string} productId Product unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public deleteProduct(productId: string, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).deleteProduct(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve information for a specific product identified by {productId}.
     * @summary Get Product
     * @param {string} productId Product unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getProduct(productId: string, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).getProduct(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all products available.
     * @summary Get All Products
     * @param {string} [skip] Skip
     * @param {string} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getProducts(skip?: string, limit?: string, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).getProducts(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update information for a specific product identified by {productId}.
     * @summary Update Product
     * @param {string} productId Product unique identifier
     * @param {UpdateProductRequest} [updateProductRequest] Update product requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public updateProduct(productId: string, updateProductRequest?: UpdateProductRequest, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).updateProduct(productId, updateProductRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProviderApi - axios parameter creator
 * @export
 */
export const ProviderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new provider with the specified information.
         * @summary Create New Provider
         * @param {CreateProviderRequest} [createProviderRequest] Create a new provider with the specified information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProvider: async (createProviderRequest?: CreateProviderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProviderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific provider identified by {providerId}.
         * @summary Delete Provider
         * @param {string} providerId Provider unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProvider: async (providerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerId' is not null or undefined
            assertParamExists('deleteProvider', 'providerId', providerId)
            const localVarPath = `/providers/{providerId}`
                .replace(`{${"providerId"}}`, encodeURIComponent(String(providerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information for a specific provider identified by {providerId}.
         * @summary Get Provider
         * @param {string} providerId Provider unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvider: async (providerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerId' is not null or undefined
            assertParamExists('getProvider', 'providerId', providerId)
            const localVarPath = `/providers/{providerId}`
                .replace(`{${"providerId"}}`, encodeURIComponent(String(providerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all providers available.
         * @summary Get All Providers
         * @param {string} [skip] Skip
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviders: async (skip?: string, limit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the information of a specific provider identified by {providerId}.
         * @summary Update Provider
         * @param {string} providerId Provider unique identifier
         * @param {UpdateProviderRequest} [updateProviderRequest] JSON object containing updated provider information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProvider: async (providerId: string, updateProviderRequest?: UpdateProviderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerId' is not null or undefined
            assertParamExists('updateProvider', 'providerId', providerId)
            const localVarPath = `/providers/{providerId}`
                .replace(`{${"providerId"}}`, encodeURIComponent(String(providerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProviderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProviderApi - functional programming interface
 * @export
 */
export const ProviderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProviderApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new provider with the specified information.
         * @summary Create New Provider
         * @param {CreateProviderRequest} [createProviderRequest] Create a new provider with the specified information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProvider(createProviderRequest?: CreateProviderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProvider(createProviderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProviderApi.createProvider']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a specific provider identified by {providerId}.
         * @summary Delete Provider
         * @param {string} providerId Provider unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProvider(providerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProvider(providerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProviderApi.deleteProvider']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve information for a specific provider identified by {providerId}.
         * @summary Get Provider
         * @param {string} providerId Provider unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProvider(providerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProvider(providerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProviderApi.getProvider']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all providers available.
         * @summary Get All Providers
         * @param {string} [skip] Skip
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProviders(skip?: string, limit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Provider>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProviders(skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProviderApi.getProviders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the information of a specific provider identified by {providerId}.
         * @summary Update Provider
         * @param {string} providerId Provider unique identifier
         * @param {UpdateProviderRequest} [updateProviderRequest] JSON object containing updated provider information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProvider(providerId: string, updateProviderRequest?: UpdateProviderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProvider(providerId, updateProviderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProviderApi.updateProvider']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProviderApi - factory interface
 * @export
 */
export const ProviderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProviderApiFp(configuration)
    return {
        /**
         * Create a new provider with the specified information.
         * @summary Create New Provider
         * @param {CreateProviderRequest} [createProviderRequest] Create a new provider with the specified information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProvider(createProviderRequest?: CreateProviderRequest, options?: any): AxiosPromise<Provider> {
            return localVarFp.createProvider(createProviderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific provider identified by {providerId}.
         * @summary Delete Provider
         * @param {string} providerId Provider unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProvider(providerId: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.deleteProvider(providerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve information for a specific provider identified by {providerId}.
         * @summary Get Provider
         * @param {string} providerId Provider unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvider(providerId: string, options?: any): AxiosPromise<Provider> {
            return localVarFp.getProvider(providerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all providers available.
         * @summary Get All Providers
         * @param {string} [skip] Skip
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviders(skip?: string, limit?: string, options?: any): AxiosPromise<Array<Provider>> {
            return localVarFp.getProviders(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the information of a specific provider identified by {providerId}.
         * @summary Update Provider
         * @param {string} providerId Provider unique identifier
         * @param {UpdateProviderRequest} [updateProviderRequest] JSON object containing updated provider information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProvider(providerId: string, updateProviderRequest?: UpdateProviderRequest, options?: any): AxiosPromise<Provider> {
            return localVarFp.updateProvider(providerId, updateProviderRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProviderApi - object-oriented interface
 * @export
 * @class ProviderApi
 * @extends {BaseAPI}
 */
export class ProviderApi extends BaseAPI {
    /**
     * Create a new provider with the specified information.
     * @summary Create New Provider
     * @param {CreateProviderRequest} [createProviderRequest] Create a new provider with the specified information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    public createProvider(createProviderRequest?: CreateProviderRequest, options?: RawAxiosRequestConfig) {
        return ProviderApiFp(this.configuration).createProvider(createProviderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific provider identified by {providerId}.
     * @summary Delete Provider
     * @param {string} providerId Provider unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    public deleteProvider(providerId: string, options?: RawAxiosRequestConfig) {
        return ProviderApiFp(this.configuration).deleteProvider(providerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve information for a specific provider identified by {providerId}.
     * @summary Get Provider
     * @param {string} providerId Provider unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    public getProvider(providerId: string, options?: RawAxiosRequestConfig) {
        return ProviderApiFp(this.configuration).getProvider(providerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all providers available.
     * @summary Get All Providers
     * @param {string} [skip] Skip
     * @param {string} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    public getProviders(skip?: string, limit?: string, options?: RawAxiosRequestConfig) {
        return ProviderApiFp(this.configuration).getProviders(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the information of a specific provider identified by {providerId}.
     * @summary Update Provider
     * @param {string} providerId Provider unique identifier
     * @param {UpdateProviderRequest} [updateProviderRequest] JSON object containing updated provider information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    public updateProvider(providerId: string, updateProviderRequest?: UpdateProviderRequest, options?: RawAxiosRequestConfig) {
        return ProviderApiFp(this.configuration).updateProvider(providerId, updateProviderRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportApi - axios parameter creator
 * @export
 */
export const ReportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Ceate a new report.
         * @summary Create New Report
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReport: async (body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information for a specific report identified by {reportId}.
         * @summary Get Report
         * @param {string} reportId Report unique identifier
         * @param {string} [skip] Skip
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReport: async (reportId: string, skip?: string, limit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('getReport', 'reportId', reportId)
            const localVarPath = `/reports/{reportId}`
                .replace(`{${"reportId"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all reports available.
         * @summary Get All Reports
         * @param {string} [skip] Skip
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReports: async (skip?: string, limit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportApi - functional programming interface
 * @export
 */
export const ReportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportApiAxiosParamCreator(configuration)
    return {
        /**
         * Ceate a new report.
         * @summary Create New Report
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReport(body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Report>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createReport(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportApi.createReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve information for a specific report identified by {reportId}.
         * @summary Get Report
         * @param {string} reportId Report unique identifier
         * @param {string} [skip] Skip
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReport(reportId: string, skip?: string, limit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Report>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReport(reportId, skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportApi.getReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all reports available.
         * @summary Get All Reports
         * @param {string} [skip] Skip
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReports(skip?: string, limit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Report>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReports(skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportApi.getReports']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportApi - factory interface
 * @export
 */
export const ReportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportApiFp(configuration)
    return {
        /**
         * Ceate a new report.
         * @summary Create New Report
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReport(body?: object, options?: any): AxiosPromise<Report> {
            return localVarFp.createReport(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve information for a specific report identified by {reportId}.
         * @summary Get Report
         * @param {string} reportId Report unique identifier
         * @param {string} [skip] Skip
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReport(reportId: string, skip?: string, limit?: string, options?: any): AxiosPromise<Report> {
            return localVarFp.getReport(reportId, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all reports available.
         * @summary Get All Reports
         * @param {string} [skip] Skip
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReports(skip?: string, limit?: string, options?: any): AxiosPromise<Array<Report>> {
            return localVarFp.getReports(skip, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReportApi - object-oriented interface
 * @export
 * @class ReportApi
 * @extends {BaseAPI}
 */
export class ReportApi extends BaseAPI {
    /**
     * Ceate a new report.
     * @summary Create New Report
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public createReport(body?: object, options?: RawAxiosRequestConfig) {
        return ReportApiFp(this.configuration).createReport(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve information for a specific report identified by {reportId}.
     * @summary Get Report
     * @param {string} reportId Report unique identifier
     * @param {string} [skip] Skip
     * @param {string} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public getReport(reportId: string, skip?: string, limit?: string, options?: RawAxiosRequestConfig) {
        return ReportApiFp(this.configuration).getReport(reportId, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all reports available.
     * @summary Get All Reports
     * @param {string} [skip] Skip
     * @param {string} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public getReports(skip?: string, limit?: string, options?: RawAxiosRequestConfig) {
        return ReportApiFp(this.configuration).getReports(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TeamApi - axios parameter creator
 * @export
 */
export const TeamApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Ceate a new team with the specified information.
         * @summary Create New Team
         * @param {CreateTeamRequest} [createTeamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam: async (createTeamRequest?: CreateTeamRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTeamRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific team identified by {teamId}.
         * @summary Delete Team
         * @param {string} teamId Team unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam: async (teamId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('deleteTeam', 'teamId', teamId)
            const localVarPath = `/teams/{teamId}`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information for a specific team identified by {teamId}.
         * @summary Get Team
         * @param {string} teamId Team unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam: async (teamId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('getTeam', 'teamId', teamId)
            const localVarPath = `/teams/{teamId}`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all the teams.
         * @summary Get All Teams
         * @param {string} [skip] Skip
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeams: async (skip?: string, limit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update information for a specific team identified by {teamId}.
         * @summary Update Team
         * @param {string} teamId Team unique identifier
         * @param {UpdateTeamRequest} [updateTeamRequest] JSON object containing updated team information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam: async (teamId: string, updateTeamRequest?: UpdateTeamRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('updateTeam', 'teamId', teamId)
            const localVarPath = `/teams/{teamId}`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTeamRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamApi - functional programming interface
 * @export
 */
export const TeamApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamApiAxiosParamCreator(configuration)
    return {
        /**
         * Ceate a new team with the specified information.
         * @summary Create New Team
         * @param {CreateTeamRequest} [createTeamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTeam(createTeamRequest?: CreateTeamRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Team>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTeam(createTeamRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamApi.createTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a specific team identified by {teamId}.
         * @summary Delete Team
         * @param {string} teamId Team unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTeam(teamId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTeam(teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamApi.deleteTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve information for a specific team identified by {teamId}.
         * @summary Get Team
         * @param {string} teamId Team unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeam(teamId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Team>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeam(teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamApi.getTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all the teams.
         * @summary Get All Teams
         * @param {string} [skip] Skip
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeams(skip?: string, limit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Team>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeams(skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamApi.getTeams']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update information for a specific team identified by {teamId}.
         * @summary Update Team
         * @param {string} teamId Team unique identifier
         * @param {UpdateTeamRequest} [updateTeamRequest] JSON object containing updated team information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTeam(teamId: string, updateTeamRequest?: UpdateTeamRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Team>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTeam(teamId, updateTeamRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamApi.updateTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TeamApi - factory interface
 * @export
 */
export const TeamApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamApiFp(configuration)
    return {
        /**
         * Ceate a new team with the specified information.
         * @summary Create New Team
         * @param {CreateTeamRequest} [createTeamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam(createTeamRequest?: CreateTeamRequest, options?: any): AxiosPromise<Team> {
            return localVarFp.createTeam(createTeamRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific team identified by {teamId}.
         * @summary Delete Team
         * @param {string} teamId Team unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam(teamId: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.deleteTeam(teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve information for a specific team identified by {teamId}.
         * @summary Get Team
         * @param {string} teamId Team unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam(teamId: string, options?: any): AxiosPromise<Team> {
            return localVarFp.getTeam(teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all the teams.
         * @summary Get All Teams
         * @param {string} [skip] Skip
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeams(skip?: string, limit?: string, options?: any): AxiosPromise<Array<Team>> {
            return localVarFp.getTeams(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update information for a specific team identified by {teamId}.
         * @summary Update Team
         * @param {string} teamId Team unique identifier
         * @param {UpdateTeamRequest} [updateTeamRequest] JSON object containing updated team information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam(teamId: string, updateTeamRequest?: UpdateTeamRequest, options?: any): AxiosPromise<Team> {
            return localVarFp.updateTeam(teamId, updateTeamRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamApi - object-oriented interface
 * @export
 * @class TeamApi
 * @extends {BaseAPI}
 */
export class TeamApi extends BaseAPI {
    /**
     * Ceate a new team with the specified information.
     * @summary Create New Team
     * @param {CreateTeamRequest} [createTeamRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public createTeam(createTeamRequest?: CreateTeamRequest, options?: RawAxiosRequestConfig) {
        return TeamApiFp(this.configuration).createTeam(createTeamRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific team identified by {teamId}.
     * @summary Delete Team
     * @param {string} teamId Team unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public deleteTeam(teamId: string, options?: RawAxiosRequestConfig) {
        return TeamApiFp(this.configuration).deleteTeam(teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve information for a specific team identified by {teamId}.
     * @summary Get Team
     * @param {string} teamId Team unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeam(teamId: string, options?: RawAxiosRequestConfig) {
        return TeamApiFp(this.configuration).getTeam(teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all the teams.
     * @summary Get All Teams
     * @param {string} [skip] Skip
     * @param {string} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeams(skip?: string, limit?: string, options?: RawAxiosRequestConfig) {
        return TeamApiFp(this.configuration).getTeams(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update information for a specific team identified by {teamId}.
     * @summary Update Team
     * @param {string} teamId Team unique identifier
     * @param {UpdateTeamRequest} [updateTeamRequest] JSON object containing updated team information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public updateTeam(teamId: string, updateTeamRequest?: UpdateTeamRequest, options?: RawAxiosRequestConfig) {
        return TeamApiFp(this.configuration).updateTeam(teamId, updateTeamRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a specific user identified by {userId}.
         * @summary Delete User
         * @param {string} userId User unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUser', 'userId', userId)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information for a specific user identified by {userId}.
         * @summary Get User
         * @param {string} userId User unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUser', 'userId', userId)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve settings information for a specific user identified by {userId}.
         * @summary Get User Settings
         * @param {string} userId User unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSettings: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserSettings', 'userId', userId)
            const localVarPath = `/users/{userId}/settings`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all users.
         * @summary Get All Users
         * @param {string} [skip] Skip
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (skip?: string, limit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invite a user.
         * @summary Invite User
         * @param {InviteUserRequest} [inviteUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteUser: async (inviteUserRequest?: InviteUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update information for a specific user identified by {userId}.
         * @summary Update User
         * @param {string} userId User unique identifier
         * @param {UpdateUserRequest} [updateUserRequest] JSON object containing updated user information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (userId: string, updateUserRequest?: UpdateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUser', 'userId', userId)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update settings information for a specific user identified by {userId}.
         * @summary Update User Settings
         * @param {string} userId User unique identifier
         * @param {UpdateUserSettingsRequest} [updateUserSettingsRequest] JSON object containing updated user settings information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserSettings: async (userId: string, updateUserSettingsRequest?: UpdateUserSettingsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUserSettings', 'userId', userId)
            const localVarPath = `/users/{userId}/settings`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a specific user identified by {userId}.
         * @summary Delete User
         * @param {string} userId User unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.deleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve information for a specific user identified by {userId}.
         * @summary Get User
         * @param {string} userId User unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve settings information for a specific user identified by {userId}.
         * @summary Get User Settings
         * @param {string} userId User unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserSettings(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Settings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserSettings(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUserSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all users.
         * @summary Get All Users
         * @param {string} [skip] Skip
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(skip?: string, limit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Invite a user.
         * @summary Invite User
         * @param {InviteUserRequest} [inviteUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteUser(inviteUserRequest?: InviteUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteUser(inviteUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.inviteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update information for a specific user identified by {userId}.
         * @summary Update User
         * @param {string} userId User unique identifier
         * @param {UpdateUserRequest} [updateUserRequest] JSON object containing updated user information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(userId: string, updateUserRequest?: UpdateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(userId, updateUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update settings information for a specific user identified by {userId}.
         * @summary Update User Settings
         * @param {string} userId User unique identifier
         * @param {UpdateUserSettingsRequest} [updateUserSettingsRequest] JSON object containing updated user settings information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserSettings(userId: string, updateUserSettingsRequest?: UpdateUserSettingsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Settings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserSettings(userId, updateUserSettingsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.updateUserSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Delete a specific user identified by {userId}.
         * @summary Delete User
         * @param {string} userId User unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userId: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.deleteUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve information for a specific user identified by {userId}.
         * @summary Get User
         * @param {string} userId User unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: string, options?: any): AxiosPromise<User> {
            return localVarFp.getUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve settings information for a specific user identified by {userId}.
         * @summary Get User Settings
         * @param {string} userId User unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSettings(userId: string, options?: any): AxiosPromise<Settings> {
            return localVarFp.getUserSettings(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all users.
         * @summary Get All Users
         * @param {string} [skip] Skip
         * @param {string} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(skip?: string, limit?: string, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.getUsers(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Invite a user.
         * @summary Invite User
         * @param {InviteUserRequest} [inviteUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteUser(inviteUserRequest?: InviteUserRequest, options?: any): AxiosPromise<User> {
            return localVarFp.inviteUser(inviteUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update information for a specific user identified by {userId}.
         * @summary Update User
         * @param {string} userId User unique identifier
         * @param {UpdateUserRequest} [updateUserRequest] JSON object containing updated user information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(userId: string, updateUserRequest?: UpdateUserRequest, options?: any): AxiosPromise<User> {
            return localVarFp.updateUser(userId, updateUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update settings information for a specific user identified by {userId}.
         * @summary Update User Settings
         * @param {string} userId User unique identifier
         * @param {UpdateUserSettingsRequest} [updateUserSettingsRequest] JSON object containing updated user settings information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserSettings(userId: string, updateUserSettingsRequest?: UpdateUserSettingsRequest, options?: any): AxiosPromise<Settings> {
            return localVarFp.updateUserSettings(userId, updateUserSettingsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Delete a specific user identified by {userId}.
     * @summary Delete User
     * @param {string} userId User unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUser(userId: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).deleteUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve information for a specific user identified by {userId}.
     * @summary Get User
     * @param {string} userId User unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(userId: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve settings information for a specific user identified by {userId}.
     * @summary Get User Settings
     * @param {string} userId User unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserSettings(userId: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserSettings(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all users.
     * @summary Get All Users
     * @param {string} [skip] Skip
     * @param {string} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUsers(skip?: string, limit?: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUsers(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invite a user.
     * @summary Invite User
     * @param {InviteUserRequest} [inviteUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public inviteUser(inviteUserRequest?: InviteUserRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).inviteUser(inviteUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update information for a specific user identified by {userId}.
     * @summary Update User
     * @param {string} userId User unique identifier
     * @param {UpdateUserRequest} [updateUserRequest] JSON object containing updated user information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUser(userId: string, updateUserRequest?: UpdateUserRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).updateUser(userId, updateUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update settings information for a specific user identified by {userId}.
     * @summary Update User Settings
     * @param {string} userId User unique identifier
     * @param {UpdateUserSettingsRequest} [updateUserSettingsRequest] JSON object containing updated user settings information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUserSettings(userId: string, updateUserSettingsRequest?: UpdateUserSettingsRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).updateUserSettings(userId, updateUserSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



